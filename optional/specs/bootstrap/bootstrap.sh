#!/usr/bin/env bash
# bootstrap.sh - Universal agent project bootstrap
# Usage: ./bootstrap.sh [--non-interactive] [--map-existing]
#
# Creates a semantic-aware project structure that works with
# any naming scheme (workshop, standard, minimal, custom)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NON_INTERACTIVE=false
MAP_EXISTING=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --non-interactive)
      NON_INTERACTIVE=true
      shift
      ;;
    --map-existing)
      MAP_EXISTING=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Check for gum
if ! command -v gum &> /dev/null && [ "$NON_INTERACTIVE" = false ]; then
  echo "gum not found. Install: brew install gum"
  echo "Or run with --non-interactive"
  exit 1
fi

# Check if already bootstrapped
if [ -f "derivation.yaml" ]; then
  echo "Project already bootstrapped (derivation.yaml exists)."
  echo "Edit derivation.yaml to reconfigure, or delete it to re-bootstrap."
  exit 0
fi

# Derive project name from directory
DEFAULT_NAME=$(basename "$(pwd)" | tr '-' ' ' | sed 's/\b\(.\)/\u\1/')

if [ "$NON_INTERACTIVE" = true ]; then
  PROJECT_NAME="$DEFAULT_NAME"
  PROJECT_SLUG=$(basename "$(pwd)")
  PROJECT_TYPE="software"
  NAMING_SCHEME="workshop"
else
  # Phase 1: Gather project info
  PROJECT_NAME=$(gum input --value "$DEFAULT_NAME" --placeholder "Project name")

  # Generate slug
  PROJECT_SLUG=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')

  PROJECT_TYPE=$(gum choose --header "Project type" "software" "research" "writing" "other")

  # Phase 2: Choose naming scheme
  NAMING_SCHEME=$(gum choose --header "Naming style for memory directories" \
    "workshop (bench/shavings/sawdust)" \
    "standard (identity/notes/sessions)" \
    "minimal (.identity/.memory/.state)" \
    "custom (specify your own)")
fi

# Resolve naming scheme to actual directories
case $NAMING_SCHEME in
  workshop*)
    IDENTITY_DIR="bench"
    IDENTITY_FILE="identity.md"
    MEMORY_DIR="shavings"
    SHORT_DIR="sawdust"
    STATE_DIR="sawdust/state"
    CONFIG_DIR=".workshop"
    WORKFLOW_PREFIX="workshop"
    ;;
  standard*)
    IDENTITY_DIR="."
    IDENTITY_FILE="identity.md"
    MEMORY_DIR="notes"
    SHORT_DIR="sessions"
    STATE_DIR=".state"
    CONFIG_DIR="config"
    WORKFLOW_PREFIX="note"
    ;;
  minimal*)
    IDENTITY_DIR="."
    IDENTITY_FILE=".identity.md"
    MEMORY_DIR=".memory"
    SHORT_DIR=".scratch"
    STATE_DIR=".state"
    CONFIG_DIR=".agent"
    WORKFLOW_PREFIX="mem"
    ;;
  custom*)
    if [ "$NON_INTERACTIVE" = false ]; then
      IDENTITY_DIR=$(gum input --placeholder "Identity directory (e.g., docs)")
      IDENTITY_FILE=$(gum input --value "identity.md" --placeholder "Identity filename")
      MEMORY_DIR=$(gum input --placeholder "Long-term memory directory (e.g., notes)")
      SHORT_DIR=$(gum input --placeholder "Short-term/session directory (e.g., sessions)")
      STATE_DIR=$(gum input --placeholder "State directory (e.g., .state)")
      CONFIG_DIR=$(gum input --placeholder "Config directory (e.g., .agent)")
      WORKFLOW_PREFIX=$(gum input --placeholder "Workflow command prefix (e.g., myproject)")
    else
      echo "Custom naming requires interactive mode"
      exit 1
    fi
    ;;
esac

# Phase 3: Generate derivation.yaml
cat > derivation.yaml << EOF
# Derivation file - maps semantic delimiters to project-specific paths
# Generated by bootstrap.sh on $(date +%Y-%m-%d)

project:
  name: "$PROJECT_NAME"
  slug: "$PROJECT_SLUG"
  type: $PROJECT_TYPE
  created: $(date +%Y-%m-%d)

memory:
  identity: "$IDENTITY_DIR/$IDENTITY_FILE"
  long: "$MEMORY_DIR/"
  short: "$SHORT_DIR/"
  state: "$STATE_DIR/"
  config: "$CONFIG_DIR/"

workflow:
  capture: "$WORKFLOW_PREFIX capture"
  search: "$WORKFLOW_PREFIX search"
  update: "$WORKFLOW_PREFIX update"
  validate: "$WORKFLOW_PREFIX check"

# Semantic delimiter resolution (for templates)
# {{PROJECT_NAME}} -> $PROJECT_NAME
# {{MEMORY:identity}} -> $IDENTITY_DIR/$IDENTITY_FILE
# {{MEMORY:long}} -> $MEMORY_DIR/
# {{MEMORY:short}} -> $SHORT_DIR/
# {{MEMORY:state}} -> $STATE_DIR/
# {{MEMORY:config}} -> $CONFIG_DIR/
EOF

# Phase 4: Create directory structure
mkdir -p "$MEMORY_DIR"
mkdir -p "$SHORT_DIR/sessions"
mkdir -p "$STATE_DIR"
mkdir -p "$CONFIG_DIR"

# Phase 5: Create identity file
if [ ! -f "$IDENTITY_DIR/$IDENTITY_FILE" ]; then
  mkdir -p "$IDENTITY_DIR"
  cat > "$IDENTITY_DIR/$IDENTITY_FILE" << EOF
# $PROJECT_NAME

**Type:** $PROJECT_TYPE
**Created:** $(date +%Y-%m-%d)

## Purpose

[What this project does - fill this in]

## Context

[Background a new agent needs to understand this project]

## Key Files

[Important entry points and what they do]

## Conventions

[Naming patterns, coding style, workflow specifics]
EOF
fi

# Phase 6: Create checkpoint template
if [ ! -f "$STATE_DIR/checkpoint.yaml" ]; then
  cat > "$STATE_DIR/checkpoint.yaml" << 'EOF'
# Checkpoint - Current recoverable state
# This file enables resumption after interruption

task:
  id: null
  title: ""
  type: null
  priority: null

phase: idle
phase_entered: null

position:
  file: null
  line: null
  context: []
  url: null

decisions: []

blockers: []

session:
  id: null
  started: null
  last_activity: null
  log: null

transitions: []
EOF
fi

# Phase 7: Create vocabulary.yaml (semantic command map)
if [ ! -f "$CONFIG_DIR/vocabulary.yaml" ]; then
  # Resolve semantic delimiters in vocabulary template
  sed -e "s|{{PROJECT_NAME}}|$PROJECT_NAME|g" \
      -e "s|{{PROJECT_SLUG}}|$PROJECT_SLUG|g" \
      -e "s|{{PROJECT_TYPE}}|$PROJECT_TYPE|g" \
      -e "s|{{WORKFLOW_PREFIX}}|$WORKFLOW_PREFIX|g" \
      -e "s|{{MEMORY:config}}|$CONFIG_DIR|g" \
      -e "s|{{MEMORY:identity}}|$IDENTITY_DIR/$IDENTITY_FILE|g" \
      -e "s|{{MEMORY:state}}|$STATE_DIR|g" \
      "$SCRIPT_DIR/templates/vocabulary.yaml" > "$CONFIG_DIR/vocabulary.yaml" 2>/dev/null || \
  cat > "$CONFIG_DIR/vocabulary.yaml" << EOF
# Semantic Vocabulary - Map semantic IDs to commands
project:
  name: "$PROJECT_NAME"
  slug: "$PROJECT_SLUG"
  type: $PROJECT_TYPE

commands:
  LR-L2-capture:
    semantic: "Save insight"
    command: "$WORKFLOW_PREFIX capture"
  LR-L3-search:
    semantic: "Find knowledge"
    command: "$WORKFLOW_PREFIX search"
  UL-L2-recover:
    semantic: "Resume work"
    command: "read:$STATE_DIR/checkpoint.yaml"

workflows:
  session-start:
    steps: [onboard, recover, prioritize]
  session-end:
    steps: [reflect, validate, handoff]
EOF
fi

# Phase 7: Create .gitignore additions if not present
if [ -f ".gitignore" ]; then
  if ! grep -q "# Agent memory" .gitignore 2>/dev/null; then
    cat >> .gitignore << EOF

# Agent memory (optional - comment out if you want to track)
# $SHORT_DIR/
# $STATE_DIR/
EOF
  fi
fi

# Phase 8: Summary
echo ""
gum style --foreground 212 --bold "✓ Bootstrapped $PROJECT_NAME"
echo ""
echo "Structure:"
echo "  $IDENTITY_DIR/$IDENTITY_FILE  - Project identity"
echo "  $MEMORY_DIR/                  - Long-term memory"
echo "  $SHORT_DIR/                   - Session data"
echo "  $STATE_DIR/                   - Checkpoints"
echo "  $CONFIG_DIR/                  - Configuration"
echo ""
echo "Semantic delimiters (for templates):"
echo "  {{PROJECT_NAME}} → $PROJECT_NAME"
echo "  {{MEMORY:identity}} → $IDENTITY_DIR/$IDENTITY_FILE"
echo "  {{MEMORY:long}} → $MEMORY_DIR/"
echo "  {{MEMORY:short}} → $SHORT_DIR/"
echo "  {{MEMORY:state}} → $STATE_DIR/"
echo ""
echo "Next: Edit $IDENTITY_DIR/$IDENTITY_FILE with project details"
